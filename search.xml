<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/2025/09/02/test/"/>
      <url>/2025/09/02/test/</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>本文将正式开始学习 C++ 中的面向对象,本篇博客涵盖讲解访问限定符、封装的基础知识、类的作用域和实例化、探究类对象的存储和对于this指针由浅入深地讲解.</p><h1 id="一、面向过程和面向对象初步认识"><a href="#一、面向过程和面向对象初步认识" class="headerlink" title="一、面向过程和面向对象初步认识"></a>一、面向过程和面向对象初步认识</h1><ul><li>C语言是面向过程的,关注的是过程,分析出求解问题的步骤,通过函数调用逐步解决问题.</li><li>C++是基于面向对象的,关注的是对象,将一件事情拆分成不同的对象,靠对象之间的交互完成.</li></ul><p>比如我现在要写一个外卖系统,面向过程关注的就是上架商品、点外卖、通知商家、分配骑手、派送、点评等操作,而面向对象关注的就是商家、用户、骑手.</p><h1 id="二、类的引入"><a href="#二、类的引入" class="headerlink" title="二、类的引入"></a>二、类的引入</h1><p>最初C++被称作“C with Classes”(包含类的C语言),是C语言的继承,进一步扩充和完善了C语言.最开始大佬们是用struct来引str入类,比如在C语言中我们用结构体来定义一个学生:(C语言只能定义变量)</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">struct Student&#123;        char _name[20];        char _gender[3];        int _age;&#125;;</code></pre><p>用C语言的方式结构体只能定义变量,C++是兼容C语言的,在C++中,结构体内不仅可以定义变量,也可以定义函数.</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">struct Student&#123;        void Init(const char* name, const char* gender, int age)        &#123;                strcpy(_name, name);                strcpy(_gender, gender);                _age &#x3D; age;        &#125;        void Print()        &#123;                cout &lt;&lt; _name &lt;&lt; &quot; &quot; &lt;&lt; _gender &lt;&lt; &quot; &quot; &lt;&lt; _age &lt;&lt; endl;        &#125;        char _name[20];        char _gender[3];        int _age;&#125;;</code></pre><p>C++对struct进行升级,把struct升级成了类,有如下标志:</p><ol><li>结构体名称可以做类型</li><li>里面可以定义函数</li></ol><p>代码演示其变化过程:</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">struct ListNode&#123;        int val;        &#x2F;&#x2F;C语言定义next只能这样定义        struct ListNode* next;        &#x2F;&#x2F;C++可以这样        ListNode* next;        &#x2F;&#x2F;C++可以定义函数,C只能定义成员        void Print()        &#123;                &#x2F;&#x2F;……        &#125;&#125;;int main()&#123;        &#x2F;&#x2F;C语言不typedef只能这样定义        struct Student s1;        &#x2F;&#x2F;C++可以这样        Student s2;        return 0;&#125;</code></pre><p>C++里面可以访问其成员也可以访问其函数:</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">struct Student&#123;        void Init(const char* name, const char* gender, int age)        &#123;                strcpy(_name, name);                strcpy(_gender, gender);                _age &#x3D; age;        &#125;        void Print()        &#123;                cout &lt;&lt; _name &lt;&lt; &quot; &quot; &lt;&lt; _gender &lt;&lt; &quot; &quot; &lt;&lt; _age &lt;&lt; endl;        &#125;        &#x2F;&#x2F;这里并不是必须加_        &#x2F;&#x2F;习惯加这个,用来表示成员变量        char _name[20];        char _gender[3];        int _age;&#125;;int main()&#123;        Student s1;        s1.Init(&quot;张三&quot;, &quot;男&quot;, 23);        s1.Print();        return 0;&#125;</code></pre><aside>➡️<p>在Init()函数中出现了const char* name,是因为strcpy函数的定义中src类型为const char*</p><p>在类中,成员变量前面会加入“<em>”,是因为C++有一个惯例,成员变量通常前面加“</em>”,以便于区分类函数中的形参变量</p><p>这里的成员变量可以定义在任何位置,不会像C语言那样受到约束,因为C++这里把struct升级成了类,类是一个整体,它会在这个整体内寻找.虽然C++把struct升级成了类,不过C++还是喜欢用class来代替struct以此来定义类.</p></aside><h1 id="三、类的定义"><a href="#三、类的定义" class="headerlink" title="三、类的定义"></a>三、类的定义</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class ClassName&#123;        &#x2F;&#x2F; 类体:由成员函数和成员变量组成&#125;;  &#x2F;&#x2F; 一定要注意后面的分号</code></pre><ul><li>class为定义类的关键字,ClassName为类的名字,{}中为类的主体,注意类定义结束时后面分号.</li><li>类中的元素称为类的成员:类中的数据称为类的属性或者成员变量; 类中的函数称为类的方法或者成员函数.</li></ul><h1 id="四、类的访问限定符及封装"><a href="#四、类的访问限定符及封装" class="headerlink" title="四、类的访问限定符及封装"></a>四、类的访问限定符及封装</h1><h2 id="访问限定符"><a href="#访问限定符" class="headerlink" title="访问限定符"></a>访问限定符</h2><ol><li>若想把里面的东西给你用就定义成公有public:</li><li>不想给你用就定义成私有private:</li><li>要保护起来的就定义成protected:</li></ol><p>C++实现封装的方式:用类将对象的属性与方法结合在一块,让对象更加完善,通过访问权限选择性的将其接口提供给外部的用户使用</p><p>访问限定符说明:(都蛮重要的)</p><ul><li>public修饰的成员在类外可以直接被访问</li><li>protected和private修饰的成员在类外不能直接被访问</li><li>访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止</li><li>如果后面没有访问限定符作用域就到}结束</li><li>class的默认访问权限为private,struct为public(因为struct要兼C)</li></ul><aside>➡️<p>访问限定符只在编译时有用,当数据映射到内存后,没有任何访问限定符上的区别</p></aside><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>面向对象的三大特性:封装、继承、多态</p><p>封装是指将数据和操作数据的方法进行有机结合,隐藏对象的属性和实现细节,仅对外公开接口来和对象进行交互.</p><p>我们都清楚C语言的数据和方法是分离的,我们以栈为例:</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;C语言的数据和方法是分离的struct Stack&#123;        int* _a;        int _top;           &#x2F;&#x2F; 数据        int _capacity;&#125;;void StackInit(struct Stack* ps)&#123;&#125;void StackPush(struct Stack* ps, int x)             &#x2F;&#x2F; 方法&#123;&#125;int StackTop(struct Stack* ps)&#123;&#125;int main()&#123;        struct Stack st;        StackInit(&amp;st);        StackPush(&amp;st, 1);        StackPush(&amp;st, 3);        StackPush(&amp;st, 5);        return 0;&#125;</code></pre><p>像C语言这样数据和方法分离会存在一个巨大的问题:太过自由！我没办法去对它很好的管理,就比如我现在想访问栈顶的数据,如若是C语言,我们就可以这样写:</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">printf(&quot;%d\n&quot;, StackTop(&amp;st));  &#x2F;&#x2F;规范printf(&quot;%d\n&quot;, st._a[st._top]); &#x2F;&#x2F;不规范</code></pre><p>按理来说,第一行的代码才是正确的,合理的,中肯的访问形式,第二行代码直接用结构去操纵成员,虽然也可以,但是会涉及到一个问题:我对top到底是栈顶元素还是栈顶元素的下一个位置？(如果初始化里的top给的是0,那st.top就是栈顶元素的下一个位置,会越界,如果是-1,那么刚好就是栈顶元素)此时就会出现误用.相反直接调用StackTop函数就完全不会出现这个问题,因为我在之前就已经处理好了,返回的值必是栈顶元素.</p><p>由此可见,C语言在这一方面太过自由了,接下来来看看C++是如何来解决的.</p><p>这就需要用到封装了.C++设计出了类,类里除了可以定义成员变量,还可以定义函数,所以我们就可以把上述栈的初始化,插入,取栈顶全放到类里,也就实现了数据和方法封装到一起.</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;1、数据和方法封装到一起,类里面&#x2F;&#x2F;2、想给你自由访问的设计成公有,不想给你访问的设计成私有class Stack&#123;public:        void Init()        &#123;&#125;        void Push(int x)        &#123;&#125;        int Top(struct Stack* ps)        &#123;&#125;private:        int* _a;        int _top;        int _capacity;&#125;;</code></pre><p>并且此段代码还实现了我想给你访问的就设计成公有,不想给你访问的就设计成私有.此时就完美避免了C语言过渡自由懒散的弊端,此时就不能再像C语言那样直接访问成员变量了,而只能用成员函数.</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">int main()&#123;        Stack st;        st.Init();        st.Push(1);        st.Push(2);        st.Push(3);        st.Push(4);        cout &lt;&lt; st.Top() &lt;&lt; endl;        &#x2F;&#x2F;cout &lt;&lt; st._a[st._top] &lt;&lt; endl; &#x2F;&#x2F;err        return 0;&#125;</code></pre><p>C++通过强制的就能让用的人更规范.并且一般情况设计类,成员数据都是私有或保护,想给你访问的函数是公有,不想给你访问的是私有或保护.</p><p>综上,C++的封装本质上就是一种更严格的管理.</p><h1 id="五、类的作用域"><a href="#五、类的作用域" class="headerlink" title="五、类的作用域"></a>五、类的作用域</h1><p>类定义了一个新的作用域,类的所有成员都在类的作用域中.在类体外定义成员,需要使用::作用域解析符指明成员属于哪个类域.</p><p>如下我们定义两个类(栈和队列)</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;栈class Stack&#123;public:        void Push(int x)        &#123;&#125;&#125;; &#x2F;&#x2F;队列class Queue&#123;        void Push(int x)        &#123;&#125;&#125;;</code></pre><p>这两个类中,我都定义了一个Push函数,此时编译器不会报错,这两个Push函数也不会构成函数重载,因为Stack类和Queue类是完全两个不同的作用域.若在Stack.h中声明,在Stack.cpp文件里进行定义,就要指定作用域,否则会报错.</p><h3 id="类的定义方式"><a href="#类的定义方式" class="headerlink" title="类的定义方式"></a>类的定义方式</h3><p>方式1:在类内定义</p><aside>➡️<p>成员函数如果在类中定义,编译器可能会将其当成内联函数处理.因此一般情况下短小函数可以直接在类里面定义,长一点的声明和定义分离</p></aside><p>方式2:声明放在.h文件中,类的定义放在.cpp文件中,此时需要加上类的作用域</p><aside>➡️<p>类成员变量仅仅只是声明而不是定义,因为没有开辟空间</p></aside><pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 变量的声明和定义 在于是否给它开空间class Data&#123;public:        void Init(int year, int mouth, int data)        &#123;            _year &#x3D; year;            _mouth &#x3D; mouth;            _data &#x3D; data;        &#125;        void Print()        &#123;            &#x2F;&#x2F; 这里的 _year 不是 private 中的_year, 而是在main函数中定义的_year             cout &lt;&lt; _year &lt;&lt; &quot; &quot; &lt;&lt; _mouth &lt;&lt; &quot; &quot; &lt;&lt; _data &lt;&lt; endl;        &#125;private:        &#x2F;&#x2F; 声明 这里的变量并没有空间,用不了        int _year;        int _mouth;        int _data;&#125;;&#x2F;&#x2F; 类  和  对象 的关系   1 v 多 :一个类就可以有多个对象&#x2F;&#x2F; 设计图   房子int main()&#123;        &#x2F;&#x2F; 这里叫定义        &#x2F;&#x2F; 对象的定义,也叫做,对象的实例化        &#x2F;&#x2F; d1 就是对象        Data d1;        &#x2F;&#x2F; 错误写法,这里是声明,不是定义,没有开空间        &#x2F;&#x2F; Data::_year &#x3D; 1;        cout &lt;&lt; sizeof(d1) &lt;&lt; endl;   &#x2F;&#x2F; 12  有三个成员变量        Data d2;        d2.Init(2022, 10, 18);        d1.Init(2023, 10, 18);        d1.Print();        d2.Print();        return 0;&#125;</code></pre><h1 id="六、类的实例化"><a href="#六、类的实例化" class="headerlink" title="六、类的实例化"></a>六、类的实例化</h1><p>用类类型创建对象的过程,称为类的实例化</p><ol><li>类只是一个模型一样的东西,限定了类有哪些成员,定义出一个类并没有分配实际的内存空间来存储它</li><li>一个类可以实例化出多个对象,实例化出的对象占用实际的物理空间,存储类成员变量</li><li>做个比方.类实例化出对象就像现实中使用建筑设计图建造出房子,类就像是设计图,只设计出需要什么东西,但是并没有实体的建筑存在,同样类也只是一个设计,实例化出的对象才能实际存储数据,占用物理空间</li></ol><h1 id="七、类对象模型"><a href="#七、类对象模型" class="headerlink" title="七、类对象模型"></a>七、类对象模型</h1><h2 id="计算类的大小"><a href="#计算类的大小" class="headerlink" title="计算类的大小"></a>计算类的大小</h2><p>现在给出这样一个类:</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Stack&#123;public:        &#x2F;&#x2F;在类里面定义        &#x2F;&#x2F;在类里定义的函数默认是内联        void Init()        &#123;            _a &#x3D; nullptr;            _top &#x3D; 0;            _capacity &#x3D; 0;        &#125;        &#x2F;&#x2F;在类里面声明        void Push(int x);        void Pop();private:        int* _a;        int _top;        int _capacity;&#125;;int main()&#123;        Stack st;        st.Init();        cout &lt;&lt; sizeof(st) &lt;&lt; endl; &#x2F;&#x2F;12&#125;</code></pre><p>这里我用类定义了一个对象st,现在想求出对象的大小,运行的结果为12.这是因为实例化后只保存成员变量,而成员函数存放在公共的代码段,因此不需要考虑 成员函数,如下图所示:</p><p><img src="/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%2023cd629db94b80719707ff449d448520/%E6%88%AA%E5%B1%8F2025-07-26_21.13.40.png" alt="截屏2025-07-26 21.13.40.png"></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 类中既有成员变量,又有成员函数class A1 &#123;public:        void f1() &#123;&#125;private:        int _a;        char _ch;&#125;;&#x2F;&#x2F; 类中仅有成员函数class A2 &#123;public:        void f2() &#123;&#125;&#125;;&#x2F;&#x2F; 类中什么都没有---空类class A3&#123;&#125;;int main()&#123;        A1 a1;        A2 a2;        A3 a3;        cout &lt;&lt; sizeof(a1) &lt;&lt; endl; &#x2F;&#x2F; 8        cout &lt;&lt; sizeof(a2) &lt;&lt; endl; &#x2F;&#x2F; 1        cout &lt;&lt; sizeof(a3) &lt;&lt; endl; &#x2F;&#x2F; 1        return 0;&#125;</code></pre><aside>➡️<p>当类里没有成员变量时,至少会给它开一个字节大小的空间,这1个字节不是为了存储有效数据,而是为了占位,表示对象存在过</p></aside><h1 id="八、结构体内存对齐规则"><a href="#八、结构体内存对齐规则" class="headerlink" title="八、结构体内存对齐规则"></a>八、结构体内存对齐规则</h1><ul><li>第一个成员在与结构体偏移量为0的地址处.</li><li>其他成员变量要对齐到某个数字(对齐数)的整数倍的地址处.注意:对齐数 &#x3D; 编译器默认的一个对齐数与该成员大小的较小值.VS中默认的对齐数为8</li><li>结构体总大小为:最大对齐数(所有变量类型最大者与默认对齐参数取最小)的整数倍.</li><li>如果嵌套了结构体的情况,嵌套的结构体对齐到自己的最大对齐数的整数倍处,结构体的整体大小就是所有最大对齐数(含嵌套结构体的对齐数)的整数倍.</li></ul><h1 id="九、this指针"><a href="#九、this指针" class="headerlink" title="九、this指针"></a>九、this指针</h1><p>this指针在面向对象编程中扮演着重要的角色,是一个指向当前对象的指针,例如对于类Date的成员函数,this是Date*类型的指针.在成员函数中可以通过this指针访问对象的成员变量和成员函数,其由编译器隐式提供,可以直接在成员函数内部使用.this指针可以在类的所有非静态成员函数中使用,包括构造函数和析构函数:</p><aside>➡️ 注意!this指针是指向当前对象的指针,其指向的是创建出来的一个对象.</aside><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Box &#123;    int length;  &#x2F;&#x2F; 定义私有的整型成员变量lengthpublic:    Box(int length) &#123;          this-&gt;length &#x3D; length;  &#x2F;&#x2F; 构造函数，初始化成员变量length    &#125;     int getLength() &#123;        return this-&gt;length;  &#x2F;&#x2F; 访问成员变量length    &#125;     void display() &#123;        std::cout &lt;&lt; &quot;Length: &quot; &lt;&lt; this-&gt;getLength() &lt;&lt; std::endl;  &#x2F;&#x2F; 类的成员函数，访问成员变量length和其他函数    &#125;&#125;;</code></pre><h2 id="this指针在实际编程中的应用"><a href="#this指针在实际编程中的应用" class="headerlink" title="this指针在实际编程中的应用"></a>this指针在实际编程中的应用</h2><p>this指针可以帮助我们解决变量命名冲突,实现链式调用,并在拷贝构造函数和赋值操作符中起到关键的作用</p><h3 id="解决变量命名冲突"><a href="#解决变量命名冲突" class="headerlink" title="解决变量命名冲突"></a>解决变量命名冲突</h3><p>在类的成员函数中,如果形参名称与类的成员变量名称相同,可以使用this指针消除歧义</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Box &#123;    int length;  &#x2F;&#x2F; 定义私有的整型成员变量lengthpublic:    void setLength(int length) &#123;        this-&gt;length &#x3D; length;  &#x2F;&#x2F; 使用this指针访问成员变量length并将参数length的值赋给它    &#125;&#125;;</code></pre><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>链式调用是一种编程技巧,可以使代码更加紧凑易读,它通过在每个成员函数中返回*this,使得多个成员函数调用可以在同一行内连续进行</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Box &#123;    int length, width;  &#x2F;&#x2F; 定义私有的整型成员变量length和widthpublic:    Box&amp; setLength(int length) &#123;  &#x2F;&#x2F; 返回一个指向当前对象的引用        this-&gt;length &#x3D; length;  &#x2F;&#x2F; 将传递的参数 length 赋给成员变量 length        return *this;  &#x2F;&#x2F; 返回指向当前对象的引用    &#125;     Box&amp; setWidth(int width) &#123;  &#x2F;&#x2F; 返回一个指向当前对象的引用        this-&gt;width &#x3D; width;  &#x2F;&#x2F; 将传递的参数 width 赋给成员变量 width        return *this;  &#x2F;&#x2F; 返回指向当前对象的引用    &#125;     void display() &#123;  &#x2F;&#x2F; 定义成员函数 display        std::cout &lt;&lt; &quot;Length: &quot; &lt;&lt; length &lt;&lt; &quot;, Width: &quot; &lt;&lt; width &lt;&lt; std::endl;  &#x2F;&#x2F; 输出成员变量 length 和 width 的值    &#125;&#125;; &#x2F;&#x2F; 使用示例Box b;b.setLength(10).setWidth(5).display();  &#x2F;&#x2F; 链式调用 setLength, setWidth, display 函数显示结果</code></pre><h3 id="拷贝构造函数和赋值操作符"><a href="#拷贝构造函数和赋值操作符" class="headerlink" title="拷贝构造函数和赋值操作符"></a>拷贝构造函数和赋值操作符</h3><p>this指针在拷贝构造函数和赋值操作符中扮演着重要的角色,在这些函数中我们通常需要检查传入的对象是否就是当前对象,即是否自我赋值,如果是则应避免进行可能导致错误的自我赋值</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Box &#123;    int* data;  &#x2F;&#x2F; 定义私有指针成员变量 data public:    &#x2F;&#x2F; 赋值运算符重载函数    Box&amp; operator&#x3D;(const Box&amp; other) &#123;        if (this !&#x3D; &amp;other) &#123;  &#x2F;&#x2F; 防止自赋值的情况            delete[] data;  &#x2F;&#x2F; 释放旧内存            data &#x3D; new int[10];  &#x2F;&#x2F; 重新分配内存            std::copy(other.data, other.data + 10, data);  &#x2F;&#x2F; 拷贝数据        &#125;        return *this;  &#x2F;&#x2F; 返回一个指向当前对象的引用    &#125;&#125;;</code></pre><h1 id="十、构造函数"><a href="#十、构造函数" class="headerlink" title="十、构造函数"></a>十、构造函数</h1><p>构造函数是一个特殊的成员函数,名字与类名相同,创建类类型对象时由编译器自动调用,保证每个数据成员都有一个合适的初始值,并且在对象生命周期内只调用一次.其特征如下:</p><ol><li>函数名和类名相同</li><li>无返回值</li><li>对象实例化时编译器自动调用对应的构造函数</li><li>构造函数可以重载,即若构造函数有参数,则在创建对象时需要在对象后传入对应的参数</li><li>如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成</li><li>一般认为无参的构造函数为默认构造函数,并且默认构造函数只能有一个.</li></ol><aside>➡️<p>可以显式定义一个默认构造函数,在函数体内空实现,并且再定义一个带参构造函数,来实现初始化逻辑.(这样做的目的是提前声明对象来开辟空间)</p></aside><p><a href="https://www.notion.so/23cd629db94b80ac8e7bd0795fd94a6f?pvs=21">缺省函数</a></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Date&#123;public:&#x2F;&#x2F;普通的构造函数        Date()        &#123;                _year &#x3D; 1;                _month &#x3D; 1;                _day &#x3D; 1;        &#125;&#x2F;&#x2F;全缺省的构造函数        Date(int year &#x3D; 1, int month &#x3D; 1, int day &#x3D; 1)        &#123;                _year &#x3D; year;                _month &#x3D; month;                _day &#x3D; day;        &#125;        void Print()        &#123;                cout &lt;&lt; _year &lt;&lt; &quot;-&quot; &lt;&lt; _month &lt;&lt; &quot;-&quot; &lt;&lt; _day &lt;&lt; endl;        &#125;private:        int _year;        int _month;        int _day;&#125;;int main()&#123;        Date d1;        d1.Print();&#125;</code></pre><h2 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h2><p>成员初始化列表是C++一种特殊的语法,用于在对象构造时直接初始化类的成员变量,而非在构造函数体内赋值.</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class 类名 &#123;private:    成员变量类型 成员1;    成员变量类型 成员2;public:    &#x2F;&#x2F; 构造函数：参数列表后接成员初始化列表    类名(参数类型 参数1, 参数类型 参数2) : 成员1(初始值1), 成员2(初始值2) &#123;        &#x2F;&#x2F; 构造函数体（可选）    &#125;&#125;;</code></pre><p>初始化基本类型成员例子如下:</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Point &#123;private:    int x;    int y;public:    &#x2F;&#x2F; 用成员初始化列表初始化 x 和 y    Point(int a, int b) : x(a), y(b) &#123;        &#x2F;&#x2F; 构造函数体可以为空，因为成员已在列表中初始化    &#125;&#125;;</code></pre><h3 id="必须使用成员初始化列表的场景"><a href="#必须使用成员初始化列表的场景" class="headerlink" title="必须使用成员初始化列表的场景"></a>必须使用成员初始化列表的场景</h3><p>在某些情况下,成员初始化列表是唯一可行的初始化方式,无法用构造函数体内赋值替代</p><p>1.初始化const成员变量</p><p>const成员变量必须在创建时初始化,且不能被修改.构造函数体内的赋值都属于修改,因此必须在初始化列表中初始化:</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Demo &#123;private:    const int num;  &#x2F;&#x2F; const 成员public:    &#x2F;&#x2F; 正确：在初始化列表中初始化 const 成员    Demo(int n) : num(n) &#123;&#125;    &#x2F;&#x2F; 错误：const 成员不能在构造函数体内赋值    &#x2F;&#x2F; Demo(int n) &#123; num &#x3D; n; &#125;  &#x2F;&#x2F; 编译报错&#125;;</code></pre><p>2.初始化引用类型成员</p><p>引用类型&amp;必须在创建时绑定到一个对象,且不能重新绑定,因此也必须在初始化列表中初始化:</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Demo &#123;private:    int&amp; ref;  &#x2F;&#x2F; 引用成员public:    &#x2F;&#x2F; 正确：在初始化列表中绑定引用    Demo(int&amp; x) : ref(x) &#123;&#125;    &#x2F;&#x2F; 错误：引用不能在构造函数体内绑定    &#x2F;&#x2F; Demo(int&amp; x) &#123; ref &#x3D; x; &#125;  &#x2F;&#x2F; 编译报错&#125;;</code></pre><p>3.如果类的成员变量是另一个类的对象,且该类没有默认构造函数(无参构造函数),则必须在初始化列表中显式调用其带参数的构造函数:</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 辅助类：只有带参数的构造函数，无默认构造函数class Date &#123;private:    int year, month, day;public:    Date(int y, int m, int d) : year(y), month(m), day(d) &#123;&#125;&#125;;class Event &#123;private:    Date eventDate;  &#x2F;&#x2F; 类类型成员，无默认构造函数public:    &#x2F;&#x2F; 正确：在初始化列表中调用 Date 的带参构造函数    Event(int y, int m, int d) : eventDate(y, m, d) &#123;&#125;    &#x2F;&#x2F; 错误：Event 的构造函数会默认调用 Date 的无参构造函数（但 Date 没有）    &#x2F;&#x2F; Event(int y, int m, int d) &#123; ... &#125;  &#x2F;&#x2F; 编译报错&#125;;</code></pre><h3 id="推荐使用成员初始化列表的场景"><a href="#推荐使用成员初始化列表的场景" class="headerlink" title="推荐使用成员初始化列表的场景"></a>推荐使用成员初始化列表的场景</h3><p>即使不是必须,以下场景推荐使用成员初始化列表,以提高效率和代码可读性:</p><p>1.初始化类类型成员(提高效率)</p><p>如果成员变量是类类型(如std::string、std::vector),使用初始化列表可以避免”默认构造+赋值“的额外开销:</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;string&gt;class Person &#123;private:    std::string name;public:    &#x2F;&#x2F; 推荐：直接调用 string 的构造函数初始化    Person(const std::string&amp; n) : name(n) &#123;&#125;    &#x2F;&#x2F; 不推荐：先默认构造空字符串，再赋值    &#x2F;&#x2F; Person(const std::string&amp; n) &#123; name &#x3D; n; &#125;  &#x2F;&#x2F; 多一次赋值操作,效率较低&#125;;</code></pre><p>2.明确初始化顺序(避免依赖问题)</p><p>成员初始化列表的初始化顺序与成员变量在类中的声明顺序一致,与列表中的顺序无关</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;private:    int b;    int a;public:    &#x2F;&#x2F; 初始化顺序是 b 先于 a（因声明顺序是 b 在 a 前）    A(int x) : a(x), b(a + 1) &#123;&#125;  &#x2F;&#x2F; 实际 b 会用未初始化的 a 计算，结果错误！&#125;;&#x2F;&#x2F; 修正：按声明顺序初始化class A &#123;private:    int b;    int a;public:    A(int x) : b(x + 1), a(x) &#123;&#125;  &#x2F;&#x2F; 正确：b 用 x 初始化，a 用 x 初始化&#125;;</code></pre><aside>➡️<p>初始化顺序由声明顺序决定,而非列表顺序!</p></aside><h3 id="成员初始化列表的其他特性"><a href="#成员初始化列表的其他特性" class="headerlink" title="成员初始化列表的其他特性"></a>成员初始化列表的其他特性</h3><p>1.可以使用构造函数的参数</p><p>初始化列表中的初始值可以是构造函数的参数、全局变量或常量:</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Circle &#123;private:    double radius;    double area;public:    Circle(double r) : radius(r), area(3.14159 * r * r) &#123;&#125;&#125;;</code></pre><p>2.可以初始化基类成员</p><p>在继承关系中，派生类的构造函数可以通过初始化列表调用基类的构造函数:</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">class Base &#123;private:    int baseNum;public:    Base(int n) : baseNum(n) &#123;&#125;&#125;;class Derived : public Base &#123;private:    int derivedNum;public:    &#x2F;&#x2F; 调用基类的构造函数初始化基类成员    Derived(int b, int d) : Base(b), derivedNum(d) &#123;&#125;&#125;;</code></pre><h1 id="十一、析构函数"><a href="#十一、析构函数" class="headerlink" title="十一、析构函数"></a>十一、析构函数</h1><p>析构函数也是特殊的成员函数,对象在销毁时会自动调用析构函数,完成类的资源清理工作,其特征如下:</p><ol><li>析构函数名是在类名前加上字符~</li><li>无参数无返回值</li><li>一个类有且只有一个析构函数.若未显式定义,系统会自动生成默认的析构函数</li><li>对象生命周期结束时,C++编译系统系统自动调用析构函数</li><li>编译器生成的默认析构函数,对会自定类型成员调用它的析构函数</li></ol><aside>➡️<p>析构的目的是为了完成资源清理,真正需要清理的是malloc、new、fopen等需要申请资源的,若类中没有申请资源时析构函数可以不写.如在构造中创建了一个sockfd,则需要使用close()系统调用关闭它</p></aside>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/09/01/hello-world/"/>
      <url>/2025/09/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
